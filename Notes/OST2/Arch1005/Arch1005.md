## Usage
- HDD/SSD Controllers
- Microprocessors
## Instruction Set Architecture
- Abstract model of computer that defines how the CPU is controlled by the software.
### RV32I
- RISC V 32 bit Integer ISA
- 40 instructions, 32 GPRs
### RV32E
- RISC V 32 bit Integer Embedded ISA
- 16 GPRs, Program Counter Register
### RV64I
- All RV32I instructions, adds 15 new ones.
### RV128I
- 128 bits wide.
- 32 GPRs + Program Counter Register
- Not ratified yet!

## Hart - Hardware Thread
- Used for Simultaneous Multithreading

![[Pasted image 20250814213553.png]]

## Data Type Sizes
- “char” = 1 byte
- “short” = 2 bytes (called a “half-word” in RISC-V)
- “int” = 4 bytes (called a “word” in RISC-V)
- “long” = 4 bytes / 32-bits on 32-bit architectures and 8 bytes / 64-bits for 64-bit architectures.
- “long long” = 8 bytes (called a “double-word” in RISC-V)

## Little and Big Endian
- Simply LSB -> Little Endian
- Likewise, MSB -> Big Endian
- Only applies to memory, not registers.
- Also only bytes, not bits.
- ![[Pasted image 20250814214052.png]]

## Architecture - Registers
- XLEN - Bit Length for registers in ISA
- RV32I / RV32E, XLEN = 32
- RV64I, XLEN = 64
- RV128I, XLEN = 128

## App Binary Interface
- Defines how DS is accessed in machine code.
- x0 = zero
- x1 = ra (Return Address)
- x2 = sp (Stack Pointer)
- x3 = gp (Global Pointer)
- x4 = tp (Thread Pointer)
	- and so on...
## NOP (RV32I / 64I)
- No Operation
- Conventions : 
	- rd = Destination GPR
	- rs = Source GPR 
	- rs1 = Source GPR 1
	- rs2 = Source GPR 2
- immN = N-bit signed immediate
- uimmN = unsigned N-bit immediate
- nzimmN = non-zero N-bit immediate
- UimmN = upper N-bit immediate

## ADDI
`addi rd, rs, imm12`
- rd = rs + (sign-extended) imm12
![[Pasted image 20250815215208.png]]

## LI
- Load Immediate to Register
- `li rd`, `imm12`
## RET
- Returns the value.
- Actual encoding is through `e.jr`, which is Compressed Jump to Register.
## JALR
- Jump and Link Register
- pc = rs + signed imm12
- rd = address after jalr instruction. (aka pc+4)

## Stack Architecture
- LIFO (Last In First Out)
- ![[Pasted image 20250816183423.png]]
- Stuff on stack : 
	- Local vars
	- Return adds
	- Registers
	- Dynamically allocated memory
	- Arguments passed between the functions
## Words
- w (32 bits)
- h (16 bits) half words
- g (64 bits) double words
## SD
- Store Double Word from Register to Memory
- `sd rs2, imm12(rs1)`
## LD 
- Load Double Word from reg to mem
- `ld rd, imm12(rs1)`
## MV
- Move reg to reg
- `mv rd, rs`
- Read from R to L.
## Frame Pointer
- Saved frame pointers help organise stack frames into singly linked list.
## Uncompressed Output
![[Pasted image 20250817184801.png]]
- `c.addi4spn` = immediate x 4 to stack pointer non destructive.
- `c.sdsp` = store double word using stack pointer.
- `c.ldsp` = consider has ld instruction only, not sp specifically.
- `c.ld` = load uncompressed double word.
- `c.lui` = load non zero 6 bit immediate into bits 17-12 of dest register.
- `c.addiw` = add immediate to word sized register 
## LW
- Load Word from Memory to Register
- `lw rd, imm12 (rs1)`
## LUI
- Load Upper Immediate
- `lui rd, Uimm20`

## Calling Conventions
- Eight registers, a0 - a7.
- First two used to return values.
- More than 8 arguments are passed on to the stack.
- First argument is located at offset zero of the stack pointer on function entry.
- ![[Pasted image 20250819211537.png]]
## JAL
- Jump and Link
- `jal rd, imm21`
- `pc = pc + imm21`
- J is also JAL with `rd` set to 0
	- `jal x0, 21`
## CALL
- Pseudoinstruction
- `call` == `auipc` + `jalr`
## Operations
- SUBW
	- subtract word register from word register
	- `subw rd, rs1, rs2`
- LB
	- load byte from memory to register
	- `lb rd, imm21(rs1)`
## AUIPC
- Add upper immediate to PC and store to register
- `auipc rd, Uimm20`
- Encoded immediate is takes as upper 20 bits of 32-bit value, bottom bits are 0 and value is added to `pc`, stored into `rd`.
- Unoptimized code allocates variables from lower to higher address.
## SH + LH + ADDW + SEXT.W
- Store Half Word
	- `sh rs2, imm12(rs1)`
- Load Half Word
	- `lh rd, imm12(rs1)`
- Add Word Register to Word Register
	- `addw rd, rs1, rs2`
- Sign Extend Word in Register 
	- Pseudo-instruction
	- `sext.w rd, rs1`
## ADDIW
- `addiw rd, rs1, imm12`
## LHU + SB + LBU
- Load Half Word Unsigned
	- `lhu rd, imm12(rs1)`
- Store Byte
	- `sb rs2, imm12(rs1)`
- Load Byte Unsigned
	- `lbu rd, imm12(rs1)`

## Boolean Ops
- `and rd, rs1, rs2`
	- AND operation
- `or rd, rs1, rs2`
	- OR operation
- `xor rd, rs1, rs2`
	- XOR operation
- `not rd, rs`
	- NOT operation
	- Pseudo instruction.
	- Actually an xor with negative one. (`xori rd, rs, imm12`)
- `ori rd, rs, imm12`
	- Bitwise OR with Immediate
- `zext.b`
	- Zero Extend Byte in Register to Double Word Register
- `andi rd, rs, 255`
	- Bit wise AND and sign extended immediate 12 to store in register
- `ori`

## BNE 
- Branch if not equal (!=)
- `bne rs1, rs2, offset`
## BGE
- Branch if greater or equal (>=)
- `bge rs1, rs2, offset`
## BGEU
- Branch if Greater or Equal, Unsigned Comparison (>=)
- `bgeu rs1, rs2, offset`
## BLT
- Branch if Less Than (<)
- `blt rs1, rs2, offset`
- Branch if Less Than Unsigned (BLTU)
## BNEZ
- Branch if not equal to zero (!= 0)
- Pseudo instruction
- `bnez rs, offset`
## BEQ
- Branch if equal (=)
- `bew rs1, rs2, offset`
- Branch if equal to ZERO (BEQZ)
	- Another pseudo instruction
## BGTZ
- Branch if Greater than Zero
- `bgtz rs, offset`
## SLLI / SRLI
- `slli rd, rs, imm5`
	- Shift 5 bits for RV32I, and 6 for RV64I.
- Shift Left, Logical by Immediate
- `srli rd, rs, imm5`
	- Same shifting change as before.
- Logical shift fills shifted bits with zeros.
- Right shift means filling in the most significant bits.
- Both are associated with `'<<' and '>>'` bit shifts.
## SLL / SRL / SRA
- Shift Left, Logical by Register
- Shift Right, Logical by Register
- `sll rd, rs1, rs2`
- Shift left by the bottom 5 bits.
- Encoded same for RV32 and RV64
- Shift Right Arithmetic 
## SLLW / SRLW
- Shift Left / Right, Logical by Register, Word Size
- `sllw rd, rs1, rs2
- Shift rs1 left by the number of bits specified by the bottom 5 bits of rs2
- `srlw rd, rs1, rs2`
- Same for SRAW and SLAW, shifting by arithmetic.
## SLLIW / SRLIW
- Shift Left, Logical, by Immediate, Word Sized.
- `slliw, rd, rs, imm5`
- Shift word sized portion of `rs` left / right by imm5 bits.
## Shifting Secrets
- Shifting left by N bits is the same as multiplying by 2^N
- Shifting right arithmetic by N bits is same as dividing by 2^N
- Compiler uses arithmetic shifts with signed variables so it can preserve the correct math for any multiplies and divides.
## LWU
- Load Word, Unsigned from Memory to Register
- `lwu rd, imm12(rs1)`
- Actually compressed form.
## SNEZ
- `snez rd, rs`
- Set if Not Equal to Zero.
- Pseudo command.
- It is actually a `SLTU` : Set if Less Than Unsigned Comparison.
- Used to optimize conditional "return 2 if input was 1, else return 3" logic.
## SGTZ
- Set if Greater Than Zero
- Pseudo instruction.
- Actually a `SLT`.
	- Set if Less Than, Signed Comparsion.
- `slt rd, rs1, rs2`
- Treated as signed comparison.
## SLTI
- Set if Less Than Immediate, Signed Comparison
- `slti rd, rs, imm12`
- `SLTIU` - for unsigned conversions.
## FENCE
- Memory Fence. Used to order I/O and memory as viewed by another hardware thread.
## EBREAK
- Actually `c.break`.
- Software breakpoints.
- Also `ECALL` for function calls.![[Screenshot 2025-08-25 at 12.22.01 PM.png]]
## MUL, DIVU, REM
- Multiply, Divide and Remainder
- `mul rd, rs1, rs2`
- `divu rd, rs1, rs2`
- `remu rd, rs1, rs2`
- Remainder is an unsigned operation.
## MULHU
- Multiply, Keep High XLEN, Unsigned * Unsigned
	- `mulhu rd, rs1, rs2`
	- Multiply XLEN rs1 times XLEN rs2 and place high XLEN bits of 2 * XLEN result into rd.
	- ![[Pasted image 20250826174204.png]]
## MULW, DIVUW, REMUW
- `mulw rd, rs1, rs2`
- `divuw rd, rs1, rs2`
- `remuw rd, rs1, rs2`
- 32 bits to 64 bits word multiplication, division and remainder
## DIV, REM, DIVW, REMW
- For signed operations of words.
## MULH, MULHSU
- Multiply, Keep High XLEN, Signed * Signed
- `mulh rd, rs1, rs2`
- Meant for both arguments to be signed.
- Multiply, Keep High XLEN, Signed * Unsigned 
- `mulhsu rd, rs1, rs2`
## RISC-V Manual
- https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf
- ![[Pasted image 20250827191921.png]]
## Inline Assembly
```asm ( assembly template : 
			 output operands   :
			 input operands    :
			 list of clobbered registers 
		   );
```
- ![[Screenshot 2025-08-28 at 11.26.58 AM.png]]
### Writing bytes to get asm
- Use `.byte` keyword, to place bytes to be interpreted as code or data.
- Specify bits in little endian order.
- Can use `.short` of 2 byte values and `.long` for 4 byte values.
## RISC-V Cheatsheet
- http://riscvbook.com/greencard-20181213.pdf