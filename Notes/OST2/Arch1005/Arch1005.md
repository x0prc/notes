## Usage
- HDD/SSD Controllers
- Microprocessors
## Instruction Set Architecture
- Abstract model of computer that defines how the CPU is controlled by the software.
### RV32I
- RISC V 32 bit Integer ISA
- 40 instructions, 32 GPRs
### RV32E
- RISC V 32 bit Integer Embedded ISA
- 16 GPRs, Program Counter Register
### RV64I
- All RV32I instructions, adds 15 new ones.
### RV128I
- 128 bits wide.
- 32 GPRs + Program Counter Register
- Not ratified yet!

## Hart - Hardware Thread
- Used for Simultaneous Multithreading

![[Pasted image 20250814213553.png]]

## Data Type Sizes
- “char” = 1 byte
- “short” = 2 bytes (called a “half-word” in RISC-V)
- “int” = 4 bytes (called a “word” in RISC-V)
- “long” = 4 bytes / 32-bits on 32-bit architectures and 8 bytes / 64-bits for 64-bit architectures.
- “long long” = 8 bytes (called a “double-word” in RISC-V)

## Little and Big Endian
- Simply LSB -> Little Endian
- Likewise, MSB -> Big Endian
- Only applies to memory, not registers.
- Also only bytes, not bits.
- ![[Pasted image 20250814214052.png]]

## Architecture - Registers
- XLEN - Bit Length for registers in ISA
- RV32I / RV32E, XLEN = 32
- RV64I, XLEN = 64
- RV128I, XLEN = 128

## App Binary Interface
- Defines how DS is accessed in machine code.
- x0 = zero
- x1 = ra (Return Address)
- x2 = sp (Stack Pointer)
- x3 = gp (Global Pointer)
- x4 = tp (Thread Pointer)
	- and so on...
## NOP (RV32I / 64I)
- No Operation
- Conventions : 
	- rd = Destination GPR
	- rs = Source GPR 
	- rs1 = Source GPR 1
	- rs2 = Source GPR 2
- immN = N-bit signed immediate
- uimmN = unsigned N-bit immediate
- nzimmN = non-zero N-bit immediate
- UimmN = upper N-bit immediate

## ADDI
`addi rd, rs, imm12`
- rd = rs + (sign-extended) imm12
![[Pasted image 20250815215208.png]]

## LI
- Load Immediate to Register
- `li rd`, `imm12`
## RET
- Returns the value.
- Actual encoding is through `e.jr`, which is Compressed Jump to Register.
## JALR
- Jump and Link Register
- pc = rs + signed imm12
- rd = address after jalr instruction. (aka pc+4)

## Stack Architecture
- LIFO (Last In First Out)
- ![[Pasted image 20250816183423.png]]
- Stuff on stack : 
	- Local vars
	- Return adds
	- Registers
	- Dynamically allocated memory
	- Arguments passed between the functions
## Words
- w (32 bits)
- h (16 bits) half words
- g (64 bits) double words
## SD
- Store Double Word from Register to Memory
- `sd rs2, imm12(rs1)`
## LD 
- Load Double Word from reg to mem
- `ld rd, imm12(rs1)`
## MV
- Move reg to reg
- `mv rd, rs`
- Read from R to L.
## Frame Pointer
- Saved frame pointers help organise stack frames into singly linked list.
## Uncompressed Output
![[Pasted image 20250817184801.png]]
- `c.addi4spn` = immediate x 4 to stack pointer non destructive.
- `c.sdsp` = store double word using stack pointer.
- `c.ldsp` = consider has ld instruction only, not sp specifically.
- `c.ld` = load uncompressed double word.
- `c.lui` = load non zero 6 bit immediate into bits 17-12 of dest register.
- `c.addiw` = add immediate to word sized register 
## LW
- Load Word from Memory to Register
- `lw rd, imm12 (rs1)`
## LUI
- Load Upper Immediate
- `lui rd, Uimm20`
<<<<<<< HEAD

## Calling Conventions
- Eight registers, a0 - a7.
- First two used to return values.
- More than 8 arguments are passed on to the stack.
- First argument is located at offset zero of the stack pointer on function entry.
- ![[Pasted image 20250819211537.png]]
## JAL
- Jump and Link
- `jal rd, imm21`
- `pc = pc + imm21`
- J is also JAL with `rd` set to 0
	- `jal x0, 21`
## CALL
- Pseudoinstruction
- `call` == `auipc` + `jalr`
## Operations
- SUBW
	- subtract word register from word register
	- `subw rd, rs1, rs2`
- LB
	- load byte from memory to register
	- `lb rd, imm21(rs1)`
=======
## AUIPC
- Add upper immediate to PC and store to register
- `auipc rd, Uimm20`
- Encoded immediate is takes as upper 20 bits of 32-bit value, bottom bits are 0 and value is added to `pc`, stored into `rd`.
- Unoptimized code allocates variables from lower to higher address.
## SH + LH + ADDW + SEXT.W
- Store Half Word
	- `sh rs2, imm12(rs1)`
- Load Half Word
	- `lh rd, imm12(rs1)`
- Add Word Register to Word Register
	- `addw rd, rs1, rs2`
- Sign Extend Word in Register 
	- Pseudo-instruction
	- `sext.w rd, rs1`
## ADDIW
- `addiw rd, rs1, imm12`
## LHU + SB + LBU
- Load Half Word Unsigned
	- `lhu rd, imm12(rs1)`
- Store Byte
	- `sb rs2, imm12(rs1)`
- Load Byte Unsigned
	- `lbu rd, imm12(rs1)`
>>>>>>> 5bc0d27434681f902aea660b020c144d7b198a06
