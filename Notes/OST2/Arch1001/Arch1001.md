## Endianness

- Big Endian - 0x12345678 stored in RAM.
- MSB of a word is stored in lowest address. Eg: 0x12, 0x34, 0x56, 0x78.
- Generally used in Network traffic.
- Applies to *memory and bytes*, not registers or bits!
- ![[Pasted image 20250802202753.png]]
- Memory dump shows left to right, top to bottom which is low to high.
- Register view shows in big endian order which is right to left => high to low.
## General Purpose Registers

- Intel has 16 GPRs + Instruction Pointer
- On x86-32, registers are 32 bits wide
- On x86-64, registers are 64 bits wide

![[CheatSheet_x86-64_Registers.pdf]]

### Naming Schemes
- R0 / Really-wide AX (RAX)
- R0-D(ouble) Word
- R0-Word
- R0-Byte

## Intel Register Conventions
- RAX - Stores function return values
- RBX - Base pointer to data section
- RCX - Counter for string and loop ops
- RDX - I/O Operations
- RSI - Source Index Pointer
- RDI - Destination Index Pointer
- RSP - Stack (top) Pointer
- RBP - Stack frame base Pointer
- RIP - Instruction Pointer

## Instructions
- NOP : No-Operation
	- Only present to pad/align bytes or to delay time
	- For simple exploits.
- 0x90 is the hex notation.

## Stack
- LIFO
- Pushed on top, Popped off the top.
- Grows down towards the low addresses.
- RSP points to the top.
### Push Quadword
- Automatically decrements the stack pointer (RSP), by 8.
- Operand can be a value in 64 bit register.
- r/mX (16, 32, 64) addressing forms.
#### r/mX Forms
- Register -> rbx
- Memory -> [rbx]
![[Pasted image 20250804212013.png]]
### Pop Quadword
- Can pop into 64 bit register or memory according to the r/mX forms.
## Calling Functions
```
int func() {
	 return 0beef;
}

int main() {
	func();
	return 0xf00d;
}
```
- CALL - Transfer control to a different function.
	- Pushes the address of the next instruction onto stack.
	- Then changes RIP to the address in instruction.
- RET - Return from Procedure
	- Two forms : POP and PUSH.
	- Pop to the top of stack : `ret`
	- Pop to the top of stack + add a constant number of bytes to RSP `ret 0x8` or `ret 0x20`
- Intel Format : 
	- mov rbp, rsp [y = 2x + 1]
- AT&T Format : 
	- mov %rsp, %rbp [1 + 2 = 3]
- MOV - Register to Register, Memory to Register, Immediate to Register
- ADD and SUB :
	- Source can be r/mX / register / immediate
	- Destination can be r/mX / register.

![[Pasted image 20250804221753.png]]

### Adding a single local variable
```
int func() {
	int i = 0x5calable;
	return i;
}

int main() {
	return func();
}
```
- Corresponding asm code : 
```
func:
sub         rsp, 18h
mov         dword ptr [rsp], 5CA1AB1eh
mov         eax, dword ptr [rsp]
add         rsp, 18h
ret

main:
sub         rsp, 28h
call        func (014000100h)
add         rsp, 29h
ret
```
![[Pasted image 20250805214256.png]]
- 4 byte view to make it more clear which bytes were modified as specified in `mov` instruction above.

### ⚠️Visual Studio fills the 16 byte alignment padding in case the hex doesn't complete and hence extra space is allocated. 

## IMUL - Signed Multiply
- Forms : 
	- imul r/mX
	- imul reg, r/mX
	- imul reg, r/mX, immediate
- Single Operand -- r/m8, 16, 32, 64 for AL, AX, EAX, RAX
- Two Operands -- r/m16, r/m32, r/m64 (Can cause truncations)
- Three Operands -- r16, r/m16, imm8 (Can cause truncations)
## MOVZX / MOVSX
- Move with Zero Extend
	- CPU unconditionally fills the high order bits of the larger register with zeros.
- Move with Sign Extend
	- CPU fills the high order bits of the destination larger register with whatever the sign bit is set to on the small value.
- Same movement as normal MOV.
- FFFF = -1
- ![[Pasted image 20250805221048.png]]

## Function Parameter Passing
- Space is allocated on the call stack as shadow store for callees to save those registers.
- Dumps the register parameters into their shadow space if needed.
## Calling Conventions
- MS Application Binary Interface (ABI) 
- System V ABI
- Called volatile registers by MS (will be changed by callee)
	- VS : RAX, RCX, RDX, R8, R9, R10, R11
	- GCC : RAX, RDI, RSI, RDX, RCX, R8, R9, R10, R11
## 32-Bit Stack Calling Conventions
- `cdecl`
	- Caller cleans the stack.
- `stdcall`
	- Callee cleans up the stack.
- These conventions perform explicit stack frame linkage.
- Every time a new function is entered, old ebp -> stack, new esp -> ebp.
- ![[Pasted image 20250806211640.png]]
## LEA - Load Effective Address
- Exception to the rule that the square brackets [ ] syntax means dereference.
- Frequently used with pointer arithmetic.
- rbx = 0x2, rdx = 0x1000
	- lea rax, [rdx + rbx * 8+5]
- Basically, some special math that can be computed in "a + b * X + Y", then it can compute the result faster if it uses the LEA instruction, rather than IMUL instruction.

## Control Flow
- Conditional - ifs, switches loops
- Unconditional - calls, goto, exceptions, interrupts
## JMP (Jump)
- Change RIP to given address without conditions.
- Used in small loops.
- `jmp -2` == infinite loop for short relative jump.
- Specifies address by near, relative address.
## JCC (Jump if Condition Met)
- JNE == JNZ (Jump if not equal, Jump if not zero), both check if Zero Flag (ZF) == 0.
- ![[Pasted image 20250807183518.png]]
- Sign Flag and Zero Flag
## CMP
- Compare two operands.
- Sub second operand from the first operand and then setting the status flag in the same manner as the SUB instruction.
- Result is discarded later on.
## INC/DEC
- Increase or Decrease value by 1.
- Modifies OF, SF, ZF, AF, PF, CF flags.
## TEST
- Like AND, but throws the results away. 
- Will often see RFLAGS with TEST instructions.

## Bit Shifting
- SHL - Shift Logical Left (<<)
- First operand is r/mX
- Second operand is either cl or a 1 byte immediate.
- Multiplies **register by 2** for each place the value is shifted.

- SHR - Shift Logical Right (>>)
- First operand is r/mX
- Second operand is either cl or a 1 byte immediate.
- Divided the **register by 2** for each place the value is shifted.

- For power functions, compilers prefer multiply and divide over shifts.

- Shift Arithmetic Left and Shift Arithmetic Right (SAL and SAR) have similar usage.

## Multiply and Divide
- DIV - Unsigned Divide (With Positive Values)
- IDIV - Signed Divide (With Negative Values)
	- DX:AX divided by r/m16: AX=Quotient, DX=Remainder
	- _The remainder takes on the sign of the dividend._
- MUL - Unsigned Multiple (With Positive Values)
	- DX:AX = AX * r/m16
- IMUL - Signed Multiply (With Negative Values)
	- r16 = r16 * r/m16

## REP STOS
- Repeat Store String
- Set *di* to start destination
- Set *ax/al* to value to store
- Set *cx* to the number of times to store
- This repeats to store the string.
## REP MOVS
- Repeat Move Data String to String
- Repeat a single instruction multiple times.
- Stores 1,2,4,8 bytes at a time.
- Moves the di and si registers forward 1/2/4/8 at a time.
## Intel / AT&T Syntax
- Intel -> Preferred on Windows
- AT&T -> Preferred on Linux/GNU
- cwde = convert sign extended 
- movslq = move long keyword (64 bit value)
- ![[Pasted image 20250809203021.png]]
- Very annoying.
## Parameter Conventions
- First 6 parameters from L to R are put in RDI, RSI, RDX, RCX, R8, R9 respectively.
- Left most parameter is at lowest address.
- ![[Screenshot 2025-08-11 at 11.31.59 AM.png]]

## VS Inline Assembly
- Subset of asm can be inserted into C code by using intrinsics.
	- __stosX (rep stos)
	- __movsX (rep movs)
	- __rotrX (ror)
- MASM Format : 
```
.code
asm_scratchpad PROC
	; code here
	mov rax, 1
	ret
	
asm_scratchpad ENDP
end
```
## GCC Inline Assembly

![[Screenshot 2025-08-12 at 12.12.19 PM.png]]
