![[Pasted image 20250911183953.png]]
## CPUID
- Another Assembly instruction for feature identification of the CPU.
- [CPUID-Docs](https://www.felixcloutier.com/x86/cpuid#the-processor-brand-index-method)
## PUSHFQ / POPFQ
- Push and Pop Stack into RFLAGS.
## Processor Execution Modes
![[Pasted image 20250912220115.png]]
### System Management Mode
- Provides a transparent mechanism for implementing platform specific functions such as power management and system security.
- Protects its memory from all other privileged code.
- Activated when CPU enters SMM through interrupt pin 'SMI#'.
### Protected Mode
- Native state of the Processor.
- Directly executes 'Real Address Mode' 8086 software.
- For backwards compatibility, virtual 8086 mode feature exists.
### Long Mode
- Created by AMD for x86-64 extensions.
- Intel calls it IA-32e or Intel64.
## Model Specific Registers (MSRs)
- Provide a way on intel systems to support an ever increasing number of feature flags.
### Naming Caveat
- Prefix "IA32_" (only a prefix).
### RDMSR - Read MSR
- Only be run by the privileged elite in kernel model.
- Output in EDX:EAX.
### WRMSR - Write MSR
- Value in EDX:EAX to MSR specified by ECX.
## Privilege Rings
- Ring 0 (kernelspace / kernelmode)
- Ring 3 (userspace / usermode)
- Lower the ring, more privileged the code.
- Segmentation is used to divide the rings.
### Segmentation
- Divides addressable memory space to various data segments.
- Translates logical addressed to linear addresses, automatically, using table lookups.
- Far Pointer = 16 bit segment selector + 32/64 bit offset.
#### Segment Registers
- Six 16 bit registers that hold a Segment Selector.
- CS - Code Segment
- SS - Stack Segment
- DS - Data Segment
- ES/FS/GS - Extra Segment Registers
- Read/Write Segment Registers with MOV
	- `MOV SR, r/m16` and `MOV r/m16, SR`
- Read/Write Segment Registers with PUSH/POP
	- `PUSH SR` `POP SR`
- Protection Rings are the interaction between RPL, RPL and CPL.
- Privilege Rings are automatically enforced by the hardware on instruction fetches and data fetches.
## Call Gates 
![[Pasted image 20250913201528.png]]
- Way to transfer control from one segment to another segment at a different privilege level.
- Return from a call through a call gate : 
	- RET can pop those back off the stack to return from an inter privilege far call.
- Call gates aren't used these days.
## Implicit and Explicit Usage
- CS/SS/DS/ES are all Implicit.
- A4/A5 are all explicit.
	- `mov rax, fs:[rbx]`
## Interrupts and Exceptions
![[Pasted image 20250914174921.png]]
- Three Types of Exceptions
	- Fault : RIP Points at Faulting Instruction
	- Trap: RIP Points at Instruction after Trapping Instruction
	- Abort: Unrecoverable
![[Pasted image 20250914175348.png]]
- SS, RSP, RFLAGS, CS and RIP are all pushed into the Handler's Stack.
### Software Generated Interrupts
- INT n : Invoke Interrupt n
- IRET : returns from an interrupt
- INT3 : 0xCC one byte that can be used to invoke Interrupt 3 for software debug breakpoints.
- INT1 : 0xF1 one byte to invoke interrupt 1 to fake hardware debug breakpoints.
- INTO : Overflow interrupt.
- UD2 : Invoke invalid opcode input.
### Tasks and Task Segment
- Task Register : Has a visible part, the segment selector and hidden part, the cached segment info which specifies size of TSS.
- RSP0/1/2 is at the most bottom side of stack.
### Interrupt Descriptor Table
- Array of <= 256 16 byte desciptor entries
- 0 through 31 are reserved for arch specific exceptions and interrupts.
- 32-255 are user defined.
### Interrupt Masking
- Useful to disable some interrupts.
- The IF in the RFLAGS register is cleared automatically when an interrupt occurs through an Interrupt Gate.
## SYSCALL - System Calls
- Save RIP of address after SYSCALl into RCX
- Change RIP to value stored in IA32_LSTAR MSR (0xC0000082).
### SYSRET
- Restore RIP from RCX.
- Restore RFLAGS from R11.
### SYSENTER / SYSEXIT (32 bit)
- For SYSENTER, Change CS to value stored in IA32_SYSENTER_CS MSR.
- For SYSEXIT, Change CS to value stored in IA32_SYSENTER_CS MSR.
### SWAPGS
- Designed to help with using SYSCALL to implement system calls, there is no kernel stack at the OS entry point.
- OSes use FS and GS to point at global data structures so they are easily accessed.
- RDFSBASE, WRFSBASE to avoid MSR instructions.
- RDGSBASE, WRGSBASE
## Time Stamp Counter
- TSC is a 64 bit counter introduced in the Pentium
- IA32_TIME_STAMP_COUNTER(0x10) MSR.
- Timing Code for performance.
- Anti Debug code which checks for the presence of a debugger by timing its own execution.
## Paging
- Physical memory is divided into fixed size chunks called pages.
- Following are the Control Registers.
## CR0
- Protection Enabled (PE, bit 0)
- Write Protect (WP, bit 16)
- Paging Enabled (PG, bit 31)
## CR4
- Page Size Extensions (PSE, bit 4) = Pages > 4KB
- Physical Address Extension (PAE, bit 5) = Allows Addresses > 2^32
- Page Global Enable (PGE, bit 7)
## CR2
- Records linear address which was attempted to be translated via a page table walk.
## CR3
- Context switch between different processes.
- ![[Pasted image 20250918184930.png]]
## PML4E
- 4 Level Paging.
## SMAP/SMEP
- Supervisor Mode Access Prevention = Dont let ring 0 read/write non supervisor.
- Supervisor Mode Execution Prevention = Dont let ting 0 execute non supervisor.
## PDPTE
- 4 level paging.
- Bit 7 page size bit.
- Indicates whether this entry should be interpreted as point at 1 GB page.
## Canonical Addresses
- Upper N unused bits must always all be 0 or 1.
- 48 bit CA
	- Bits [63:47] must all be the same.
- ![[Pasted image 20250919213428.png]]
- Most OSes Kernel are in Upper Range.
- Most OSes Userspaces are in Lower Range.
## Page Faults
- The address that the MMU was attempting to translate to a physical address automatically put into the CR2.
- Recoverable Faults
	- Page is paged out / swapped to disk.
	- Automatic stack growth.
	- Attempts to write to read only memory.
- Unrecoverable Faults
	- No valid linear to physical translation.
	- Attempts to write read only memory.
	- User code accessing memory marked as supervisor.
	- SMP/SMEP permission violations.
## TLB (Translation Lookaside Buffer)
- Similar to the way that the hidden part of a segment register stores the information from a segment descriptor, so that the MMU doesn't have to go look up information from the GDT all the time.
- https://csillustrated.berkeley.edu/PDFs/handouts/cache-3-associativity-handout.pdf
- [Shadow Walker](https://www.blackhat.com/docs/us-14/materials/us-14-Torrey-MoRE-Shadow-Walker-The-Progression-Of-TLB-Splitting-On-x86.pdf)
## NX/XD Bit 
- No Execute Bit an AMD x86 extension.
- Intel called it the eXecute Disable bit.
- Helps software build exploit mitigations by marking areas such as the stack and heap as non-executable.
- Implements a W^X (Write XOR Execute) instruction.
- PGDs with XD = 1, are non executable.
	- ![[Pasted image 20250921164327.png]]
- Attempts result in a Page Fault.
- XD is used as Data Execution Prevention.
## Hardware Debug Registers
- DR0 - DR7 are debug regs.
	- DR0 - 3 : breakpoint linear address registers
	- DR4 - 5 : reserved (unused)
	- DR6 : Debug Status Register
	- DR7 : Debug Control Register
## Resume Flag
- ![[Pasted image 20250922213228.png]]
- The data is overwritten before the exception is generated.
- Instruction breakpoints are actually detected before the instruction executes.
- This is where Resume Flag is used.
- The processor ignores instruction breakpoints for the duration of the next instruction.
## Trap Flag
- Causes a debug exception after every instruction.
- Called a "single step" mode.