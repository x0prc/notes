## Loading Symbols

- `.reload` : force it to load symbols from the cache or to download new symbols that aren’t cached.
## Displaying Local Variables

- When you are source-level debugging, you can use the “**D**isplay Local **V**ariables” ([dv](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/dv--display-local-variables-)) command, or you can open the Local Variables window.
## Displaying Structures

- The “**D**isplay **T**ype” ([dt](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/dt--display-type-)) command can both display the fields of a structure, and interpret the memory at a given address according to a given structure type.
## Break on Module Load
- The **S**et E**x**ception (sx) [family of commands](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/sx--sxd--sxe--sxi--sxn--sxr--sx---set-exceptions-), can be used to break when particular events occur. The most important forms are:

- **E**nable: sx**e**
- **I**gnore: sx**i**

- There is a [long list](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/controlling-exceptions-and-events) of possible exception events, but for now we want to just look at the module **l**oa**d** (ld) event. When doing _userspace_ debugging a “module” can be a .exe or .dll. In _kernel mode_ a “module” is a .sys kernel driver (or the technically-a-.exe NT kernel itself.)
## Listing Modules

- The “**L**ist Loaded **M**odules” ([lm](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/lm--list-loaded-modules-)) command by itself will list both userspace modules (like ntdll.dll) and kernel modules (like win32k.sys), if any are available in the current execution context where the debugger is broken.
- Userspace only : `u`
- Kernel only : `k`
- List and Sort Modules : `lm sm`
- List with Filesystem Path : `f`
- List for Address
## Kernel Only Commands
### Process
- ``!process -1 [flags]``
### Listing Processes
- `!process 0 [flags]`
### Search Process Context
- `!process 0 [flags] [exe name]`
### Search Process Context on exec PID
- `!process [PID] [flags]`
## Global Descriptor Table (GDT)
- Defines regions of code and data, including the privilege levels at which they can be used.
``` 
  0: kd> !ms_gdt
    |-----|-----|---------|-----|-----------|--------------------------|--------------------|
    | Cre | Idx | Present | DPL | RawS+Type | Type (interpreted)       | Base               | 
    |-----|-----|---------|-----|-----------|--------------------------|--------------------|
    |   0 |   0 |       0 |   0 |         0 | Not present, not valid   | 0x0000000000000000 |
    |   0 |   1 |       0 |   0 |         0 | Not present, not valid   | 0x0000000000000000 |
    |   0 |   2 |       1 |   0 |        1b | Code RE Ac               | 0x0000000000000000 |
    |   0 |   3 |       1 |   0 |        13 | Data RW Ac               | 0x0000000000000000 |
    |   0 |   4 |       1 |   3 |        1b | Code RE Ac               | 0x0000000000000000 |
    |   0 |   5 |       1 |   3 |        13 | Data RW Ac               | 0x0000000000000000 |
    |   0 |   6 |       1 |   3 |        1b | Code RE Ac               | 0x0000000000000000 |
    |   0 |   7 |       0 |   0 |         0 | Not present, not valid   | 0x0000000000000000 |
    |   0 |   8 |       1 |   0 |         b | TSS32/64 (Busy)          | 0xFFFFF8010B662000 |
    |   1 |   0 |       0 |   0 |         0 | Not present, not valid   | 0x0000000000000000 |
    |   1 |   1 |       0 |   0 |         0 | Not present, not valid   | 0x0000000000000000 |
    |   1 |   2 |       1 |   0 |        1b | Code RE Ac               | 0x0000000000000000 |
    |   1 |   3 |       1 |   0 |        13 | Data RW Ac               | 0x0000000000000000 |
    |   1 |   4 |       1 |   3 |        1b | Code RE Ac               | 0x0000000000000000 |
    |   1 |   5 |       1 |   3 |        13 | Data RW Ac               | 0x0000000000000000 |
    |   1 |   6 |       1 |   3 |        1b | Code RE Ac               | 0x0000000000000000 |
    |   1 |   7 |       0 |   0 |         0 | Not present, not valid   | 0x0000000000000000 |
    |   1 |   8 |       1 |   0 |         b | TSS32/64 (Busy)          | 0xFFFFFFFFFFBB7000 |
```

## Interrupt Descriptor Table
- `!idt`
- For handling software and hardware interrupts.
## Pool
- `!pool`
- The Windows kernel has multiple “pools”, which are really just heaps from which memory can be allocated. 
- Pools can have different ["tags"](https://techcommunity.microsoft.com/t5/ask-the-performance-team/an-introduction-to-pool-tags/ba-p/372983), to help developers identify which allocations came from their own code (if they specified a custom tag at allocation time), or when the data is from a pool of all the same type of data structures.
## Windows Interrupt Request Level (IRQL)
- `!irql`
- This refers to the prioritization of different interrupt and scheduled sources. So for instance two different types of hardware interrupts might come in, but one (for instance an inter-processor-interrupt) could be put on a list for processing before the other (for instance a clock timer interrupt). 
- Both of which are much higher priority than the normal background thread scheduling activity of context switching between threads which are blocked or which have used all their allotted time.